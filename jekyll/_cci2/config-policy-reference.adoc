---
description: Open preview of config policy management for CircleCI
contentTags: 
  platform:
  - Cloud
---
= Config policy reference
:page-layout: classic-docs
:page-liquid:
:icons: font
:toc: macro
:toc-title:

NOTE: Config policy management is available on the **Scale** plan and is currently in **open preview**. All aspects of the feature are subject to change.

CAUTION: While config policy management is in open preview stage, it should **not** be used for compliance purposes. The feature might become unavailable occasionally during **open preview**, during which build configurations may **not** be evaluated against policies.

This reference page lists a selection of _helpers_, or CircleCI-specific funtions that are likely to be useful for you when you are writing your policies. These helpers will lead to _cleaner_ policies with less boilerplate.

The `circle-policy-agent` package includes built-in functions for common config policy
use cases. All policies evaluated by the `policy-service`, the `circle-cli`, or the `circle-policy-agent`
will be able to access these functions. This also means the package name `circleci.config` is
reserved.

[#circleci-rego-helpers]
== CircleCI rego helpers

[#orbs]
=== `orbs`

`orbs` is a Rego object containing orbs and versions present in the given config file. It 
can be utilized by policies related to orbs.

[#definition-orbs]
==== Definition

[source,rego]
----
orbs[string] = string
----

Example `orbs` object:

[source,json]
----
{
    "circleci/security": "1.2.3",
    "circleci/foo": "3.2.1"
}
----

[#usage-orbs]
==== Usage

[source,rego]
----
package org

import data.circleci.config

policy_name["example"]

my_orbs := config.orbs
----

[#ban-orbs]
=== `ban_orbs`

This function violates a policy if a config includes orbs based on the orb name. Versions should not 
be included in the provided list of orbs.

[#definition-ban-orbs]
==== Definition

[source,rego]
----
ban_orbs_version([string])
returns { string: string }
----

[#usage-ban-orbs]
==== Usage

[source,rego]
----
package org

import data.circleci.config

policy_name["example"]

ban_orbs = config.ban_orbs(["evilcorp/evil"])

enable_rule["ban_orbs"]

hard_fail["ban_orbs"]
----

[#ban-orbs-version]
=== `ban_orbs_version`

This function violates a policy if a config includes orbs based on the orb name and version.

[#definition-ban-orbs-version]
==== Definition

[source,rego]
----
ban_orbs_version([string])
returns { string: string }
----

[#usage-ban-orbs-version]
==== Usage

[source,rego]
----
package org

import data.circleci.config

policy_name["example"]

ban_orbs_versioned = config.ban_orbs_version(["evilcorp/evil@1.2.3", "foo/bar@4.5.6"])

enable_rule["ban_orbs_versioned"]

hard_fail["ban_orbs_versioned"]
----

[#resource-class-by-project]
=== `resource_class_by_project`

This function accepts a resource class to project IDs set mapping. The resource classes defined in the
mapping will be reserved for its associated projects. Resource classes not included in the mapping will
still be available for use by any project.

[#definition-resource-class-by-project]
==== Definition

```rego
resource_class_by_project({
  "$RESOURCE_CLASS": {$PROJECT_IDS...},
  ...
})
returns { ...reasons: string }
```

[#usage-resource-class-by-project]
==== Usage

[source,rego]
----
package org

import future.keywords
import data.circleci.config

policy_name["example"]

check_resource_class = config.resource_class_by_project({
  "large": {"$PROJECT_UUID_A","$PROJECT_UUID_B"},
})

enable_rule["check_resource_class"]

hard_fail["check_resource_class"]
----

[#contexts-allowed-by-project-ids]
=== `contexts_allowed_by_project_ids`

This function accepts a list of contexts (`context_list`) and a project id (`project_id`). 
It disables the usage of a context in a project (`project_id`), that is not included in the `context_list`.

[#definition-contexts-allowed-by-project-ids]
==== Definition

[source,rego]
----
contexts_allowed_by_project_ids(
  PROJECT_ID <type string>
  [ALLOWED_CONTEXTS...] <type list_of_strings>
)
returns reason <type string>
----

[#usage-contexts-allowed-by-project-ids]
==== Usage

[source,rego]
----
package org

import future.keywords
import data.circleci.config

policy_name["a_unique_policy_name"]

rule_contexts_allowed_by_project_ids = config.contexts_allowed_by_project_ids(
  "${PROJECT_UUID}",
  ["${ALLOW_CONTEXT_1}","${ALLOW_CONTEXT_2}"]
)

enable_rule["rule_contexts_allowed_by_project_ids"]

hard_fail["rule_contexts_allowed_by_project_ids"]
----


[#contexts-blocked-by-project-ids]
=== `contexts_blocked_by_project_ids`

This function accepts a list of contexts (`context_list`) and a project id (`project_id`). 
It blocks the usage of a context in a project (`project_id`), that is included in the `context_list`.

[#definition-contexts-blocked-by-project-ids]
==== Definition

[source,rego]
----
contexts_blocked_by_project_ids(
  PROJECT_ID <type string>
  [BLOCKED_CONTEXTS...] <type list_of_strings>
)
returns reason <type string>
----

[#usage-contexts-blocked-by-project-ids]
==== Usage

[source,rego]
----
package org

import future.keywords
import data.circleci.config

policy_name["a_unique_policy_name"]

rule_contexts_blocked_by_project_ids = config.contexts_blocked_by_project_ids(
  "${PROJECT_UUID}",
  ["${BLOCKED_CONTEXT_1}","${BLOCKED_CONTEXT_2}"]
)

enable_rule["rule_contexts_blocked_by_project_ids"]

hard_fail["rule_contexts_blocked_by_project_ids"]
----


[#contexts-reserved-by-project-ids]
=== `contexts_reserved_by_project_ids`

This function accepts a list of contexts (`context_list`) and a project id (`project_id`). 
The list of contexts provided in the `context_list` is reserved only for the project with `project_id`. 
No other project is allowed to use the contexts in the `context_list`, however other contexts can be used.

[#definition-contexts-reserved-by-project-ids]
==== Definition

[source,rego]
----
contexts_reserved_by_project_ids(
  PROJECT_ID <type string> 
  [RESERVED_CONTEXTS...] <type list_of_strings>
)
returns reason <type string>
----

[#usage-contexts-reserved-by-project-ids]
==== Usage

[source,rego]
----
package org

import future.keywords
import data.circleci.config

policy_name["a_unique_policy_name"]

rule_contexts_reserved_by_project_ids = config.contexts_reserved_by_project_ids(
   "${PROJECT_UUID}",
  ["${RESERVED_CONTEXT_1}","${RESERVED_CONTEXT_2}"]
)

enable_rule["rule_contexts_reserved_by_project_ids"]

hard_fail["rule_contexts_reserved_by_project_ids"]
----


[#contexts-reserved-by-branches]
=== `contexts_reserved_by_branches`

This function accepts a list of contexts (`context_list`) and a list of the VCS branch (`branch_list`). 
The list of contexts provided in the `context_list` gets reserved only for the branches in the `branch_list`. 
No other branch is allowed to use the contexts in the `context_list`, however other contexts can be used.

[#definition-contexts-reserved-by-branches]
==== Definition

[source,rego]
----
contexts_reserved_by_branches(
  [BRANCH_LIST...] <type list_of_strings>
  [CONTEXT_LIST...] <type list_of_strings>
)
returns reason <type string>
----

[#usage-contexts-reserved-by-branches]
==== Usage

[source,rego]
----
package org

import future.keywords
import data.circleci.config

policy_name["a_unique_policy_name"]

rule_contexts_reserved_by_branches = config.contexts_reserved_by_branches(
   ["${BRANCH_1}, "${BRANCH_2}", "${BRANCH_3}"]",
  ["${RESERVED_CONTEXT_1}","${RESERVED_CONTEXT_2}"]
)

enable_rule["rule_contexts_reserved_by_branches"]

hard_fail["rule_contexts_reserved_by_branches"]
----