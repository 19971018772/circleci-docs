---

description: コンテナ (新しいコンテナランナー) のバージョンのオープンプレビュー:
- クラウド
---
= コンテナエージェント (コンテナランナー) のオープンプレビュー
:page-layout: classic-docs
:page-liquid:
:icons: font
:toc: macro
:toc-title:

CircleCI の新しいタイプのセルフホストランナーに関するドキュメントが**オープンプレビュー**でご利用いただけるようになりました。

toc::[]

[#introduction-and-motivation]
== 概要と経緯

CircleCI のこれまでの <<runner-overview#,セルフホストランナー>> は、ジョブと、セルフホストランナーのバイナリと同じ環境で起動された <<configuration-reference#machine,仮想マシン (VM)>> の 1 対 1 のマッピングを使って各ジョブを実行していました。 このように VM でジョブを排他的に実行する場合、ユーザーは <<using-docker#,Docker Executor>> を使用する際に、CircleCI のクラウドプラットフォームが提供する、次のようなコンテナベースソリューションのメリットのいくつかを手放すことになります。

* ジョブ実行時に、カスタム Docker イメージをシームレスに定義、パブリッシュ、使用する
* カスタム Docker イメージを使って依存関係やライブラリを簡単に管理する (依存関係を `.circleci/config.yml` ステップの一環として列挙する必要なし)
* Docker イメージをダウンロードしてコンテナ内のジョブを実行する各 Docker ジョブを使ってクリーンビルド環境にアクセスすることで、軽量のコンテナベーステクノロジーを最大限に活用する

コンテナエージェント (最終的な機能名は検討中) は、現在オープンプレビューで利用できるテクノロジーです。ユーザーはこれをプライベートの Kubernetes (k8s) クラスタにインストールすることで、ネイティブな Docker Executor を使用するジョブを CircleCI のクラウドプラットフォームで実行するように、Docker ジョブをセルフホストコンピューティング環境で実行できます。

コンテナエージェントは既存のセルフホストランナーの補完機能であり、代替機能ではありません。

コンテナエージェントバイナリのインストール後、コンテナエージェントは Docker ジョブを要求し、それらをエフェメラルポッドでスケジュール設定し、コンテナベースの実行環境で操作を実行します。

.コンテナエージェントモデル - コンテナエージェントとタスクエージェント
image::container-agent-model.png[Container agent model]

[#install-and-usage-instructions]
== インストールと使用に関する注意事項

WARNING: この製品はベータ版のため、使用の際は注意が必要です。

CircleCI でセルフホストランナーエージェント (コンテナエージェントを含む) を使用する前に、 <<runner-concepts#namespaces-and-resource-classes,リソースクラス>> とそれに関連するリソースクラストークンを <<runner-installation#circleci-web-app-installation,作成>> してください。 これは、CircleCI Web アプリ (推奨) または <<runner-installation-cli#,CircleCI CLI>> を使って行えます。 リソースクラストークンは、以下に示す `agent.resourceClasses` パラメーターで使用されます。

[#preqrequisites]
=== 前提条件

* Kubernetes 1.12 以上
* Helm 3.x
* ランナーのリソースクラストークン
* コンテナエージェントが、他のワークロードがない状態で、Kubernetes 名前空間で実行されていること (エージェントまたはガベージコレクション (GC) によって、同じ名前空間内のジョブが削除される可能性があるため)
* `checkout` ステップで、SSH からチェックアウトするように git が設定されていること。 これを使用する場合は、ポート 22 からのアウトバウンド接続を許可するようにクラスタが設定されていることを確認してください。

[#installing-the-helm-chart]
=== Helm チャートのインストール

NOTE: 以下の内容は、オープンプレビューの期間中に変更される可能性があります。

コンテナエージェントは、インストールに Helm チャートを使用します。 `container-agent` というリリース名で Helm チャートをインストールするには、次を実行します。

* `helm repo add circleci https://circleci-binary-releases.s3.amazonaws.com/charts/` を実行してコンテナエージェント Helm repo を追加した後で `helm repo update` を実行します。
* `helm show values circleci/container-agent` を実行するとデフォルト値を確認できます。これを、以下の install コマンドに `--values` フラグまたは `--set name=value` フラグを指定することで上書きします。
** デフォルト値のうち、上書きが必要なのは `agent.resourceClasses` のみです。
* チャートをインストールするには `helm install container-agent circleci/container-agent -n circleci` を実行します。

この結果、コンテナエージェントが `container-agent` というリリース名で Kubernetes クラスタにデプロイされます。 次の「パラメーター」セクションは、コンテナエージェントのインストール時に設定できるパラメーターを示しています。

[#parameters]
=== パラメーター

以下は **CircleCI 固有の設定**です。

[.table.table-striped]
[cols=3*, options="header", stripes=even]
|===
|パラメーター
|説明
|デフォルト

|agent.runnerAPI
|ランナー API の URL
|https://runner.circleci.com

|agent.name
|この特定の `container-agent` インスタンスに割り当てる名前 (できれば一意の名前)。 この名前は、CircleCI UI の Runner Inventory ページに表示されます。 指定しない場合は、デプロイメントの名前がデフォルトで設定されます。
|`container-agent` (デプロイメントの名前)

|agent.resourceClasses *ジョブを正常に実行するため、デフォルト値の更新が必要*
|リソースクラスタスクの設定。 以下のリソースクラスの設定に関するセクションを参照してください。
|" "

|agent.terminationGracePeriodSeconds
|コンテナエージェントをシャットダウンする際の、終了までの猶予期間
|18300

|agent.maxRunTime
|タスクの最大実行時間。 この値は、上記の猶予期間より短くなければなりません。指定可能な値については <<runner-config-reference/#runner-max_run_time#, docs>> を参照してください。
|5 時間

|agent.maxConcurrentTasks
|同時に要求または実行できるタスクの最大数
|20

|agent.kubeGCEnabled
|ガベージコレクションを有効または無効にするオプション
|true

|agent.agent.kubeGCThreshold
|GC に削除されるまでにポッドが実行できる時間
|5 時間 5 分
|===

---

以下は **Kubernetes オブジェクトの設定**です。 先頭に `agent` が付いたパラメーターはコンテナエージェントポッド用で、ジョブが実行されるエフェメラルポッド用ではありません。

[.table.table-striped]
[cols=3*, options="header", stripes=even]
|===
|パラメーター
|説明
|デフォルト

|nameOverride
|チャート名を上書きします。
|" "

|fullnameOverride
|生成されたフルネームを上書きします。
|" "

|agent.replicaCount
|デプロイするコンテナエージェントの数。 デフォルト値の 1 のままにすることをお勧めします。
|1

|agent.image.registry
|エージェントイメージのレジストリ
|" "

|agent.image.repository
|エージェントイメージのレポジトリ
|circleci/container-agent

|agent.pullPolicy
|エージェントイメージのプルポリシー
|ifNotPresent

|agent.tag
|エージェントイメージのタグ
|latest

|agent.pullSecrets
|コンテナエージェントポッド用 (タスクを実行するエフェメラルポッド用ではない) の link:https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/[シークレットオブジェクト] コンテナのプライベートレジストリの認証情報
|[]

|agent.matchLabels
|Match labels used on agent pods
|app: container-agent

|agent.podAnnotations
|Extra annotations added to agent pods
|{}

|agent.podSecurityContext
|Security context policies added to agent pods
|{}

|agent.containerSecurityContext
|Security context policies add to agent containers
|{}

|agent.resources
|Custom resource specifications for Container Agent pods
|{}

|agent.nodeSelector
|Node selector for agent pods
|{}

|agent.tolerations
|Node tolerations for agent pods
|{}

|agent.tolerations
|Node tolerations for agent pods
|[]

|agent.affinity
|Node affinity for agent pods
|{}

|serviceAccount.create
|Create a custom service account for the agent
|true

|rbac.create
|Create a Role and RoleBinding for the service account
|
|===

Container agent needs the following Kubernetes permissions:

* Pods, Pods/Exec, Pods/Log
** Get
** Watch
** リスト
** Create
** Delete
* Secrets
** リスト
** Create
** Delete

By default a `Role`, `RoleBinding` and service account are created and attached to the container agent pod, but if you customize these, the above are the minimum required permissions.

It is assumed that container agent is running in a Kubernetes namespace without any other workloads. It is possible that the agent or garbage collection (GC) could delete pods in the same namespace.

[#resource-class-configuration-custom-pod]
=== Resource class configuration and custom task pod configuration

To run a job with no custom configuration, simply add the following configuration to the Helm chart `values.yaml`.  `MY_TOKEN` is your Runner resource class token.

```yaml
resourceClasses:
  namespace/my-rc:
    token: MY_TOKEN
```

Skip to <<#running-a-job,Running a job>> to run your first job, or keep reading to learn how to provide custom configuration to your pods.

Container Agent supports claiming and running tasks from multiple resource classes concurrently, as well as customization of the Kubernetes resources created to run tasks for a particular resource class. Configuration is provided by a map object in the Helm chart `values.yaml`.

Each resource class supports the following parameters:

- `token`: The runner resource class token used to claim tasks (**required**).
- Custom Kubernetes pod configuration for pods used to run CircleCI jobs.

The pod configuration takes all fields that a normal link:https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#debugging[Kubernetes pod does]. If service containers are used in a CircleCI job, the first `container` spec is used for all containers within the task pod. There is currently no way to provide a different container configuration between service containers and the main task container.

The following fields will be overwritten by container agent to ensure correct task function, and expected CircleCI configuration behavior:

- `spec.containers[0].name`
- `spec.containers[0].container.image`
- `spec.containers[0].container.args`
- `spec.containers[0].container.command`
- `spec.containers[0].container.workingDir`
- `spec.restartPolicy`
- `metadata.name`
- `metadata.namespace`

Below is a full configuration example, containing two resource classes:

```yaml
resourceClasses:
  circleci-runner/resourceClass:
    token: TOKEN1
    metadata:
      annotations:
        custom.io: my-annotation
    spec:
      containers:
        - resources:
            limits:
              cpu: 500m
          volumeMounts:
            - name: xyz
              mountPath: /path/to/mount
      securityContext:
        runAsNonRoot: true
      imagePullSecrets:
        - name: my_cred
      volumes:
        - name: xyz
          emptyDir: {}

  circleci-runner/resourceClass2:
    token: TOKEN2
    spec:
      imagePullSecrets:
        - name: "other"
```

[#running-a-job]
=== ジョブの実行

Once you have installed container agent within your cluster, create and trigger a CircleCI Docker job to validate the installation.

- Within your `circleci/config.yml` file, use the <<using-docker#,Docker executor syntax>> combined with the resource class that you have included in the `resourceClasses` section of your container agent installation.
- Specifically, to route a job to be run using container agent within your cluster, update the resource class stanza to use the resource class that you created for Container Agent jobs:
+
```YAML
resource_class: <namespace>/<name-of-resource-class-created>
```

NOTE: **Do not** use an existing Docker job that uses <<building-docker-images#,setup_remote_docker>> (see <<#limitations,Limitations>> section below for details).

Once your configuration file is updated, validate whether the job ran successfully by triggering it and ensuring a green build using the CircleCI web app. See the <<#sample-configuration-container-agent,FAQ section>> for a full sample config if you are starting from scratch.

[#garbage-collection]
== ガベージ コレクション

Container agent has a garbage collector which will ensure any pods and secrets with the label `app.kubernetes.io/managed-by=circleci-container-agent` left dangling in the cluster are removed. By default this will remove all jobs older than five hours and five minutes. This can be shortened or lengthened via the `agent.kubeGCThreshold` parameter. However, if you do shorten the garbage collection (GC) frequency, also shorten the max task run time via the `agent.maxRunTime` parameter to be a value smaller than the new GC frequency. Otherwise a running task pod could be removed by the GC.

Container agent will drain and restart cleanly when sent a termination signal. At this point in the open preview, container agent will not automatically attempt to launch a task that fails to start. This can be done in the CircleCI web app.

At this time, if container agent crashes, there is no expectation that in-process or queued tasks are handled gracefully. As the open preview progresses, additional crash handling will be added and documented.

[#cost-and-availability]
== Cost and availability

Container agent jobs are eligible for <<persist-data#managing-network-and-storage-use,Runner Network Egress>>. This is in line with the existing pricing model for self-hosted runners, and will happen with close adherence to the rest of CircleCI’s network and storage billing roll-out. If there are questions, reach out to your point of contact at CircleCI.

The same plan-based offerings for self-hosted runner link:https://circleci.com/pricing/#comparison-table[concurrency limits] apply to the container agent open preview. Final pricing and plan availability will be announced closer to the general availability of the offering.

[#limitations]
== 制限事項

As container agent is in an preview state, there are several known limitations. This is not meant to be an exhaustive list, but rather a selection of the limitations that are most notable. This list is not static, and lack of support at this time is not an indication of the functionality never being supported.

* The ability to rerun a job with SSH.
* Any known <<runner-overview#limitations,limitation>> for the existing self-hosted runner will continue to be a limitation of container agent.
* Building Docker images:
** There is no first-class support at this time for building container images with container agent (for example, `setup_remote_docker`).
** Users have three options at this time to build Docker images that will be used by container agent, all of which are recommended over Docker in Docker (DIND):
1. セルフホストランナー:
**** Create a separate runner resource class that is exclusively for building Docker images.
**** Install the `machine` runner on a VM and assign it to the resource class you have reserved for building Docker images. Install Docker in the VM as well.
**** In your CircleCI configuration, create a build image job. Enumerate the Docker commands to build your image without using `setup_remote_docker` and specify the build image resource class you created above. Ensure that the build image job runs before the job(s) that use that image that was built. At the end of your build image job, push the image up and subsequently use container agent to pull that image and run your Docker job(s).
1. CircleCI-hosted compute:
**** Use Remote Docker or a Linux machine executor as described above in Building Docker images bullet point, using CircleCI-hosted compute to run Docker commands in a build image job.
**** In your CircleCI configuration, execute the build image job before the job(s) that use that image that was built. At the end of your "build image" job, push the image up and subsequently use container agent to pull that image and run your Docker job(s).
**** link:https://docs.gitlab.com/ee/ci/docker/using_docker_build.html#use-docker-in-docker[Docker in Docker] is not recommended due to the security risk it can pose to your cluster.
1. link:https://podman.io/[Podman]:
**** There are no blockers to using a technology like Podman to build Docker images within a Docker job.
* There is no support for container environments other than Kubernetes at this time.
* There is no support for the installation of container agent via the UI-based install flow in the web app, with the exception of creating a runner resource class that can be used with container agent.
* <<docker-layer-caching#,Docker Layer Caching (Docker layer caching)>> does not work on self-hosted runners and will also not work with container agent.
* There is a difference between how container agent and CircleCI cloud set the entrypoint of the <<glossary#primary-container,primary container>>. On cloud, the entrypoint of the primary container is ignored unless it is preserved using the `com.circleci.preserve-entrypoint=true LABEL` instruction (see: <<custom-images#adding-an-entrypoint#,Adding an entrypoint>>). In contrast, container agent will always default to a shell (`/bin/sh`), or the entrypoint specified in the job configuration, if set.
** **Note:** Entrypoints should be commands that run forever without failing. If the entrypoint fails or terminates in the middle of a build, the build will also terminate. If you need to access logs or build status, consider using a background step instead of an entrypoint.
* Container agent does not yet work on link:https://circleci.com/pricing/server/[CircleCI's server offering]

[#how-to-receive-technical-help]
== How to receive technical help

Contact your point of contact at CircleCI directly or comment on the link:https://discuss.circleci.com/t/a-more-scalable-container-friendly-self-hosted-runner-container-agent-now-in-open-preview/45094[Discuss post].

[#faqs]
== FAQ

[#what-is-a-CircleCI-task-vs-a-job]
=== What is a CircleCI task vs. a job?

A task is the smallest unit of work on CircleCI. If a job has <<parallelism-faster-jobs#,parallelism>> of one, it is one task. If a job has parallelism = n and n > 1, then the job creates n tasks to execute.

[#what-is-a-runner-resource-class]
=== What is a runner resource class? What is a resource class token?

A resource class is a label to match your CircleCI job with a type of runner (or container agent) that is identified to process that job. The first part of the resource class is your organization’s namespace. たとえば、 `circleci/documentation` などです。

Resource classes help you identify a pool of self-hosted runners, which allow you to set up your configuration to send jobs to specific resources. For example, if you have multiple machines running macOS, and multiple machines running Linux, you could create resource classes for each of these, orgname/macOS and orgname/linux, respectively. `.circleci/config.yml` のジョブレベルでは、リソースクラスに基づいて、ジョブの送信先となるセルフホストランナーのリソースを関連付けることができます。

Every time you create a resource class, a *resource class token* is generated that is associated with the given resource class. This token is the method by which CircleCI authenticates that the resource class is valid.

[#only-one-resource-class-allowed-per-container-agent-deployment]
=== Is there only one resource class allowed per container agent deployment?

No, you can use as many resource classes as you desire with your container agent deployment. At least one resource class is required in order to run a job successfully with container agent.

[#does-container-agent-use-a pull-model]
=== Does container agent use a pull or push based model?

Container agent uses a pull-based model.

[#does-container-agent-scale-my-kubernetes-cluster]
=== Does Container Agent scale my Kubernetes cluster for me?

Container agent itself is its own deployment of a single replica set that does not currently require scaling. Container agent will not scale the Kubernetes cluster itself. It schedules work if there are available resources in the cluster.

As the technology is still in its early phases, the upper bound of how many concurrent tasks container agent can schedule without unforeseen issues is still being tested.

You can use the <<runner-scaling#,queue depth API>> as a signal for cluster scaling.

[#limit-for-the-number-of-concurrent-tasks]
=== Is there a limit for the number of concurrent tasks that container agent can handle?

Container agent will claim and schedule work up to your runner concurrency limit. Additionally, by default, container agent is configured with a limit of 20 tasks it will allow to be concurrently scheduled and running.This can be configured via Helm to be a different value if your funner concurrency allows for a value greater than 20. See the `agent.maxConcurrentTasks` parameter in the <<#parameters,Parameters>> section above.

An organization’s runner concurrency limit is shared with any existing `machine` self-hosted runners. If you do not know what your organization's runner concurrency limit is, ask your point of contact at CircleCI, or submit a link:https://support.circleci.com/hc/en-us[support ticket].

[#build-docker-images-with-container-agent]
=== Can I build Docker images with container agent either via Remote Docker or Docker in Docker (DIND)?

There is no first-class support at this time for building container images with container agent (for example, `setup_remote_docker`).

Docker in Docker is not recommended due to the security risk it can pose to your cluster. The recommendation at this time is to either use a dedicated VM using the existing `machine` self-hosted runner to build Docker images in your workflow, or use CircleCI-hosted compute, or use a technology like link:https://podman.io/[Podman].

[#can-i-use-something-other-than-kubernetes]
=== Can I use something other than Kubernetes with Container Agent?

At this time, no. Kubernetes and Helm are required.

[#require-specific-kubernetes-providers]
=== Does container agent require specific Kubernetes providers?

At this time, no.

=== What is the difference between the existing Kubernetes runner and container agent?

**Existing Kubernetes runner**

The existing Kubernetes runner runs `launch-agent` (the component in charge of polling CircleCI for work) on Kubernetes. It runs `task-agent` (the component in charge of executing work) within the same pod, as though it is running on a VM.

The `task-agent` is not aware that it is running on Kubernetes.

The old Kubernetes runner still uses a 1:1 ratio of `launch-agent` : `task-agent`.

**Container agent**

Container agent is aware of Kubernetes and uses it to schedule `task-agent`. They run in separate pods and there is a 1:Many ratio between container agent and associated task agents.

[#need-to-sit-within-the-cluster]
=== Does container agent need to sit within the cluster that it deploys pods to?

As of now, yes.

[#what-platforms-can-you-install-container-agent-on]
=== What platforms can you install container agent on?

As of now, amd64 Linux for both the container agent itself and the pods that execute tasks.

[#emit-messages-from-container-agent]
=== Is there a way to emit messages from container agent to other parts of the Kubernetes cluster via lifecycle hooks?

As of right now, no.

[#how-do-i-uninstall-container-agent]
=== How do I uninstall container agent?

To uninstall the `container-agent` deployment, run:

```bash
$ helm uninstall container-agent
```

The command removes all the Kubernetes objects associated with the chart and deletes the release.

[#replace-the-existing-self-hosted-runner]
=== Does container agent replace the existing self-hosted runner from CircleCI?

No, container agent is meant to complement the existing `machine` self-hosted runner. With container agent and the existing `machine` self-hosted runner, CircleCI users have the flexibility to choose the execution environment they desire (Docker vs. Machine) just like they are afforded on CircleCI’s cloud platform.

[#increase-agent-replicacount]
=== What happens if I increase `agent.ReplicaCount`?

Currently, Kubernetes will attempt to deploy an additional container agent. This is not recommended at this time as this scenario is untested and may not work as expected.

[#how-does-the-agent-maxconcurrenttasks-parameter-work]
=== If there are two container agents deployed to a single Kubernetes cluster, how does the `agent.maxConcurrentTasks` parameter work?

The `agent.maxConcurrentTasks` parameter applies to each agent individually. However, multiple container agent deployments per Kubernetes cluster is not recommended at this time.

[#updates-to-container-agent-functionality]
=== Will there be updates to container agent functionality during open preview?

Yes, the product is in continuous development. Updates to container agent itself should flow to any container agent that is deployed automatically. No action required on the user’s end.

Updates to the Helm chart can be link:https://atlassian.github.io/data-center-helm-charts/userguide/upgrades/HELM_CHART_UPGRADE/[applied] via:

```bash
$ helm repo update
$ helm upgrade container-agent
```

If there is a major change in functionality, CircleCI will update the documentation on this page.

[#security-implications]
=== What are the security considerations for container agent?

Just like the existing self-hosted runner, container agent allows users to run arbitrary code in the infrastructure where container agent is hosted, meaning a bad actor could potentially use it as a method to gain knowledge of internal systems. Ensure you are following all best practices for security to mitigate this risk.

[#sample-configuration-container-agent]
=== What does a full sample configuration look like that uses container agent?

```yaml
version: 2.1

jobs:
  build:
    docker:
      - image: cimg/base:2021.11
    resource_class: <namespace>/<resource-class>
    steps:
      - checkout
      - ...

workflows:
  build-workflow:
    jobs:
      - build
```