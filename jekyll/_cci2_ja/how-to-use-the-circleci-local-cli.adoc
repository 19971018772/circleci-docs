---

layout: classic-docs
title: How to use the CircleCI local CLI
description: How to use the CircleCI local CLI
redirect_from: 2.0/local-jobs
version:
- Cloud
- Server v2.x
- Server v3.x
---

This page describes how to use some features of the CircleCI CLI.

[#orb-development-kit]
== Orb 開発キット

The <<orb-author#create-test-and-publish-an-orb,orb development kit>> refers to a suite of tools that work together to simplify the <<orb-intro#,orb>> development process, with automatic testing and deployment on CircleCI. There are two commands in the CLI that are a part of the orb development kit:

The following command link:https://circleci-public.github.io/circleci-cli/circleci_orb_init.html[initializes a new orb project]:

```shell
circleci orb init
```

The following command link:https://circleci-public.github.io/circleci-cli/circleci_orb_pack.html[packs an orb with local scripts]:

```shell
circleci orb pack
```

For more information on orb packing, see the <<orb-concepts#orb-packing,Orbs Concepts>> page.

[#validate-an-orb-in-your-configuration-file]
== Validate an orb in your configuration file

You can validate your orb with the following:

```shell
circleci orb validate /tmp/my_orb.yml
```

The above command will look for an orb called `my_orb.yml` in the `/tmp` folder of the directory in which you ran the command.

[#packing-a-config]
== 設定ファイルのパッケージ化

```shell
circleci config pack
```

This CLI pack command (separate to `circleci orb pack` described above) allows you to create a single YAML file from several separate files (based on directory structure and file contents). The `pack` command implements link:https://github.com/CircleCI-Public/fyaml[FYAML], a scheme for breaking YAML documents across files in a directory tree. これは、容量の大きな Orbs のソース コードを分割している場合に特に利便性が高く、Orbs の YAML 構成のカスタム編成を行うことができます。

How you **name** and **organize** your files when using the `pack` command will determine the final `orb.yml` output. Consider the following folder structure example:

```shell
$ tree
.
└── your-orb-source
    ├── @orb.yml
    ├── commands
    │   └── foo.yml
    └── jobs
        └── bar.yml

3 directories, 3 files
```

The unix `tree` command is great for printing out folder structures. In the example tree structure above, the `pack` command will map the folder names and file names to **YAML keys**, and map the file contents as the **values** to those keys.

The following command will `pack` up the example folder from above:

```shell
$ circleci config pack your-orb-source
```

And the output will be in your `.yml` file:

```yaml
# ここに @orb.yml の内容が表示されます
commands:
  foo:
    # ここに foo.yml の内容が表示されます
jobs:
  bar:
    # ここに bar.yml の内容が表示されます
```

[#other-configuration-packing-capabilities]
=== Other configuration packing capabilities

A file beginning with `@` will have its contents merged into its parent folder level. This can be useful at the top level of an orb, when one might want generic `orb.yml` to contain metadata, but not to map into an `orb` key-value pair.

たとえば、以下のコマンドは

```shell
$ cat foo/bar/@baz.yml
{baz: qux}
```

以下のようにマップされます。

```yaml
bar:
  baz: qux
```

[#processing-a-config]
== 設定ファイルの処理

Running the following command validates your config, but will also display expanded source configuration alongside your original configuration (useful if you are using orbs):

```shell
circleci config process
```

Consider the following example configuration that uses the link:https://circleci.com/developer/orbs/orb/circleci/node[`node`] orb:

```yml
version: 2.1

orbs:
  node: circleci/node@4.7.0

workflows:
  version: 2
  example-workflow:
      jobs:
        - node/test
```

Running the following command will output a YAML file like the example below (which is a mix of the expanded source and the original configuration commented out):

```shell
circleci config process .circleci/config.yml
```

```yml
# Orb 'circleci/node@4.7.0' resolved to 'circleci/node@4.7.0'
version: 2
jobs:
  node/test:
    docker:
    - image: cimg/node:13.11.0
    steps:
    - checkout
    - run:
        command: |
          if [ ! -f "package.json" ]; then
            echo
            echo "---"
            echo "Unable to find your package.json file. Did you forget to set the app-dir parameter?"
            echo "---"
            echo
            echo "Current directory: $(pwd)"
            echo
            echo
            echo "List directory: "
            echo
            ls
            exit 1
          fi
        name: Checking for package.json
        working_directory: ~/project
    - run:
        command: |
          if [ -f "package-lock.json" ]; then
            echo "Found package-lock.json file, assuming lockfile"
            ln package-lock.json /tmp/node-project-lockfile
          elif [ -f "npm-shrinkwrap.json" ]; then
            echo "Found npm-shrinkwrap.json file, assuming lockfile"
            ln npm-shrinkwrap.json /tmp/node-project-lockfile
          elif [ -f "yarn.lock" ]; then
            echo "Found yarn.lock file, assuming lockfile"
            ln yarn.lock /tmp/node-project-lockfile
          fi
          ln package.json /tmp/node-project-package.json
        name: Determine lockfile
        working_directory: ~/project
    - restore_cache:
        keys:
        - node-deps-{{ arch }}-v1-{{ .Branch }}-{{ checksum "/tmp/node-project-package.json" }}-{{ checksum "/tmp/node-project-lockfile" }}
        - node-deps-{{ arch }}-v1-{{ .Branch }}-{{ checksum "/tmp/node-project-package.json" }}-
        - node-deps-{{ arch }}-v1-{{ .Branch }}-
    - run:
        command: "if [[ !   version: 2
  example-workflow:
    jobs:
    - node/test

# Original config.yml file:
# version: 2.1
#
# orbs:
#   node: circleci/node@4.7.0
#
# workflows:
#   version: 2
#   example-workflow:
#       jobs:
#         - node/test
```

[#run-a-job-in-a-container-on-your-machine]
== マシン上のコンテナ内でのジョブの実行

The CLI enables you to run jobs in your configuration with Docker. This can be useful to run tests before pushing configuration changes, or debugging your build process without impacting your build queue.

[#prerequisites]
=== 前提条件

You will need to have link:https://www.docker.com/products/docker-desktop[Docker] installed on your system, as well as the most recent version of the CLI. You will also need to have a project with a valid `.circleci/config.yml` file in it.

[#running-a-job]
=== ジョブの実行

The CLI allows you to run a single job from CircleCI on your desktop using Docker with the following command:

```shell
$ circleci local execute --job JOB_NAME
```

If your CircleCI configuration is set to version 2.1 or greater, you must first export your configuration to `process.yml`, and specify it when executing with the following commands:

```shell
circleci config process .circleci/config.yml > process.yml
circleci local execute -c process.yml --job JOB_NAME
```

The following commands will run an example build on your local machine on one of CircleCI's demo applications:

```shell
git clone https://github.com/CircleCI-Public/circleci-demo-go.git
cd circleci-demo-go
circleci local execute --job build
```

The commands above will run the entire `build` job (only jobs, not workflows, can be run locally). The CLI will use Docker to pull down the requirements for the build and then execute your CI steps locally. In this case, Golang and Postgres Docker images are pulled down, allowing the build to install dependencies, run the unit tests, test the service is running, and so on.

[#limitations-of-running-jobs-locally]
=== ローカルでのジョブ実行時の制限事項

Although running jobs locally with `circleci` is very helpful, there are some limitations.

**Machine executor**

ローカルジョブでは Machine Executor を使用できません。 Machine Executor でジョブを実行するには、別の VM が必要になるためです。

**Add SSH keys**

It is currently not possible to add SSH keys using the `add_ssh_keys` CLI command.

**Workflows**

CLI ツールでは、ワークフローの実行がサポートされていません。 基本的にワークフローは、複数のマシンでのジョブの並列実行を活用することによって、高速で複雑なビルドを可能にします。 Because the CLI is only running on your machine, it can only run single jobs (which make up parts of a workflow).

**Caching and online-only Commands**

現在、ローカルジョブではキャッシュがサポートされていません。 When you have either a <<configuration-reference#savecache,`save_cache`>> or <</configuration-reference#restorecache,`restore_cache`>> step in your config, `circleci` will skip them and display a warning.

また、オンラインでは機能しても、ローカルマシンでは機能しないコマンドもあります。 For example, the Golang build reference above runs a <<configuration-reference#storeartifacts,`store_artifacts`>> step, however, local builds will not upload artifacts. ローカルのビルドで利用できないステップがあった場合は、コンソールにエラーが表示されます。

**Environment variables**

For security reasons, encrypted environment variables configured in the link:https://app.circleci.com/[web application] will not be imported into local builds. As an alternative, you can specify environment variables to the CLI with the `-e` flag. See the output of the following command for more information.

```shell
circleci help build
```

If you have multiple environment variables, you must use the flag for each variable, for example:

```shell
circleci build -e VAR1=FOO -e VAR2=BAR
```

[#test-splitting]
== テストの分割

The CircleCI CLI is also used for some advanced features during job runs, for example <<parallelism-faster-jobs#using-the-circleci-cli-to-split-tests,test splitting>> for build time optimization.

[#context-management]
== コンテキストの管理

<<contexts#,コンテキスト>> は、環境変数を保護し、プロジェクト間で共有するためのメカニズムを提供します。 While contexts have been traditionally managed on the CircleCI web application, the CircleCI CLI provides an alternative method for managing the usage of contexts in your projects. With the CLI, you can execute several context-oriented commands:

- `create` - Create a new context
- `delete` - Delete the named context
- `list` - List all contexts
- `remove-secret` - Remove an environment variable from the named context
- `show` - Show a context
- `store-secret` - Store a new environment variable in the named context

これらは CLI の "サブコマンド" であり、以下のように実行されます。

```shell
circleci context create

# Returns the following:
List all contexts

Usage:
  circleci context list <vcs-type> <org-name> [flags]
```

Many commands will require that you include additional information as indicated by the parameters delimited by `< >`.

As with most of the CLI's commands, you will need to have properly authenticated your version of the CLI with a token to enable performing context related actions.

[#next-steps]
== 次のステップ

- <<executor-intro#,Introduction to Execution Environments>>