---

version:
- クラウド
- Server v3.x
- Server v2.x
---
= テスト分割によるパイプラインの迅速化
:page-layout: classic-docs
:page-liquid:
:page-description: CircleCI でテストを分割し、実行する方法について説明します。
:icons: font
:toc: macro

:toc-title:

このガイドでは、テスト分割の基本的な例を紹介します。 テスト分割によりパイプラインを高速化することができます。

toc::[]

== はじめに

テスト分割は、複数の実行環境でテストを同時に実行する手法です。 テスト分割は、CircleCI のジョブを異なる Node で同時に実行できる <<parallelism-faster-jobs#,_parallelism_>> という機能を使います。

何十個または何百個のテストで構成されたテストスイートがあり、それらを一つづつ実行するには長時間かかり、大量のクレジットを消費します。 テストを分割すると、待機時間が大幅に減り、より迅速にフィードバックを得ることができ、プランの使用を最適化できます。

CircleCI のテスト分割は、Jest、pytest、Maven、 Gradle などの多くのテストフレームワークで使用できます。

このチュートリアルでは以下を行います。

* 基本的な React アプリを CircleCI のプロジェクトとして設定する
* プロジェクトの `.circleci/config.yml` ファイルをタイミングデータに基づいてテストを分割するように変更する
* その結果のテストの並列実行を CircleCI Web アプリで確認する
* テスト分割により、パイプラインの実行時間がどれだけ減少したか、またクレジットの使用がどれほど最適化されたかを確認する

このチュートリアルに沿って実行するには、以下を準備する必要があります。

* CircleCI のアカウント: アカウントをお持ちでない場合は、 <<first-steps#,無料で登録していただけます。>>
* CircleCI アカウントに関連付けられたバージョン管理システム (VCS) プロバイダー (GitHub や BitBucket)  : まだお済みでない場合は、<<gh-bb-integration#,GitHub と Bitbucket の連携>> のページの手順に従って VCS プロバイダーの関連付けをしてください。

== サンプルアプリについて

このチュートリアルでは基本的な React アプリを使用します。 このプロジェクトのリポジトリは、[GitHub] (https://github.com/ryanpedersen42/circleci-react-test-splitting) でご確認ください。 このアプリは、[React アプリの作成] (https://create-react-app.dev/) を使って作成され、[Jest] (https://jestjs.io/) のテストフレームワークを使用するように設定されています。 [jest-junit] Reporter (https://github.com/jest-community/jest-junit) を使ってテスト結果を JUnit XML ファイルとしてエクスポートします。

このチュートリアルの後半で CircleCI のプロジェクトをセットアップする場合は、編集が可能な config.yml テンプレートを使用するオプションを選択します。 このチュートリアルで使用するテンプレートは、Node プロジェクトで使用可能なスターター設定です。 下記セクションで設定の簡単な説明を読むか、CircleCI での Node プロジェクトの設定に慣れている場合は、先に進んでプロジェクトの設定を行なってください。

=== 設定ファイルの詳細

下記は、config.yml テンプレートのコピーで、後で編集します。

[source,yaml]
----
version: 2.1

orbs:
  node: circleci/node@4.7

jobs:
  build-and-test:
    docker:
      - image: cimg/node:16.10
    steps:
      - checkout
      - node/install-packages:
          pkg-manager: npm
      - run:
          name: Run tests
          command: npm test

workflows:
  sample:
    jobs:
      - build-and-test
----

*  **1 行目:** このプロジェクトでは `version: 2.1` の設定ファイルを使用します。 それにより、Orb や再利用可能な設定などの CircleCI 機能が有効化されます。 Version 2.1 の設定ファイルに関する詳細は、関連ドキュメント <<configuration-reference#,CircleCI の設定>> を参照してください。
* **3-4 行目:** このプロジェクトでは CircleCI Node <<orb-intro#,Orb>> を使用します。 Node Orb は、再利用が可能な設定要素のパッケージで、Node.js アプリに共通のタスクを実行し、config.yml ファイルの複雑さを軽減します。 この特定のサンプルでは、 Orb の `install-packages` コマンドを使って Node パッケージを簡単にインストールし、`pkg-manager` パラメーターを使って Yarn をデフォルトのパッケージマネージャーとして設定しています。 Node Orb に関する詳細は、[Developer Hub] (https://circleci.com/developer/orbs/orb/circleci/node) を参照してください。
* **18-21 行目:** プロジェクトのパイプラインは、`sample` と呼ばれるワークフローで構成されています。 このワークフローは `build-and-test` という名前の一つのジョブで構成され、このジョブは、プロジェクトコードのチェックアウト、Node パッケージのインストール、デフォルトパッケージマネージャーの設定、テストの実行を行う複数のステップで構成されています。

テスト分割は通常、一つのジョブ内で設定されます。 このチュートリアルでは、`build-and-test` ジョブを変更し、並列実行するテストの数、テストスイートの場所、およびテストの分割方法 (今回はタイミングで) を定義します。

== ステップ 1: プロジェクトを追加する

まずはじめに、CircleCI でサンプルアプリをプロジェクトとしてビルドする必要があります。

. GitHub の https://github.com/ryanpedersen42/circleci-react-test-splitting/fork で [Fork the repository]、またはリポジトリをダウンロードして、プロジェクトコードを任意の VCS プロバイダーにプッシします。
. [CircleCI Web アプリ] (https://app.circleci.com) を開きます。 お客様個人の組織であることを確認し (`\https://app.circleci.com/pipelines/<vcs-provider><your-vcs-username>`)、 **Projects** に移動します。
. プロジェクトの一覧からサンプルアプリを見つけ、**Set Up Project** をクリックします。
. config.yml ファイルを選択するよに求められます。 そのウィンドウで、"Fast: Take me to a config.yml template that I can edit" オプションを選択します。 **Set Up Project** をクリックします。
. サンプルの設定ファイル一覧が表示されます。 ウィンドウ内でスクロールダウンすると、**Node (Advanced)** が表示されるので、**Select** をクリックします。
+
image::{{site.baseurl}}/assets/img/docs/test-splitting-sample-configs.png[Sample config for Node]
. すると、設定ファイルに移動します。 プロジェクトでは実際には Yarn を使うため、`npm` の代わりに `yarn` を使うように下記ステップを編集する必要があります。

+
[source,yaml]
----
steps:
# Checkout the code as the first step.
- checkout
# Next, the node orb's install-packages step will install the dependencies from a package.json.

# The orb install-packages step will also automatically cache them for faster future runs.

- node/install-packages:
    # If you are using yarn, change the line below from "npm" to "yarn"
    pkg-manager: yarn
- run:
    name: Run tests
    command: yarn test
----
. 変更したら、先に進み **Commit and Run** ボタンをクリックします。  `circleci-project-setup` と呼ばれる新しい新機能ブランチでこの変更をコミットし、新しいパイプラインをトリガーします。
+
image::{{site.baseurl}}/assets/img/docs/test-splitting-first-pipeline.png[Successful pipeline run]
+
緑色の Success ステータスを拡張して `build-and-test` ジョブを開き、パイプラインで実行されたステップをご自由にご覧ください。
+
image::{{site.baseurl}}/assets/img/docs/test-splitting-first-setup-steps.png[Steps run successfully within the job]

== ステップ 2: テスト分割をセットアップする

コードリポジトリのローカルコピーをダウンロードしたら、テキストエディターで下記の手順を実行し、`.circleci/config.yml` に変更を加えます。 または、CircleCI Web アプリでブランチを選択し、**Edit Config** ボタンを選択すると、プロジェクトの設定を編集できます。

. `build-and-test` ジョブで、`docker` キーの後に `parallelism` キーと 値 `5` を追加します。
+
[source,yaml]
----
parallelism: 5
----
+
テスト分割を有効にするには、この parallelism キーを 1 よりも大きな値に設定し、テストが必ず複数の Executor に分散されるようにします。 値が 1 だと、テストが一つの環境内で順次実行され、テスト時間やクレジット使用量を減らせるというメリットが得られません。
+
この例では、5 つの別々の Docker コンテナがスピンアップされます。
. `build-and-test` ジョブの `steps` キー内で以下の更新を行います。
.. `node/install-packages` ステップの後に `run` コマンドを追加して、`junit` という名前の新しいサブディレクトリを作成します。
+
[source,yaml]
----
- run: mkdir ~/junit
----
+
タイミングデータを含むテスト結果が Executor のサブディレクトリに保存します。
.. 既存の `Run tests` という名前の `run` コマンドと下記を入れ替えます。
+
[source,yaml]
----
- run:
      name: Test application
      command: |
          TEST=$(circleci tests glob "src/__tests__/*.js" | circleci tests split --split-by=timings)
          yarn test $TEST

----
+
このステップでは CircleCI CLI を使ってテストスイートの場所に渡し、テストをどのように分割するかを設定します。 `circleci tests glob` コマンドを使ってテストファイルを選択できます。
* まず、 `+src/_tests__/*.js+` のグロブパターンに合うファイル、つまり、 `+src/_tests__+ ` とそのサブディレクトリにあるすべての `.js` ファイルを指定します。
* Then, the matching files are piped into `circleci tests split`, which creates the test split groupings.
* The `--split-by=timings` flag indicates that the tests should be split according to timing data. For other test splitting options, consult the <<parallelism-faster-jobs#splitting-test-files,Splitting test files section of the Running Tests in Parallel>> document.
+
NOTE: The `circleci tests` commands (`glob` and `split`) cannot be run locally via the CLI as they require information that only exists within a CircleCI container.
+
The CircleCI CLI commands do not actually execute the tests⁠—you still need to run `yarn test` for that. For convenience, the CircleCI CLI output of test split groupings is stored in the `$TEST` environment variable that can be referenced when running `yarn test`.
.. After the `Test application` command, add a new `run` command like so:
+
[source,yaml]
----
- run:
    command: cp junit.xml ~/junit/
    when: always
----
+
This copies the test results (saved as JUnit XML files) to the `~/junit` subdirectory created in an earlier step. Using the `when` attribute with a value of `always` will execute this particular step _always_ regardless of whether the preceding steps were executed successfully or not.
.. Finally, add a `store_test_results` step:
+
[source,yaml]
----
- store_test_results:
    path: ~/junit
----
+
This step uploads the test data to CircleCI and is **required** to split tests by timing data. This step allows test data to be accessible on the Tests tab of the job in the CircleCI web app, and can be helpful for debugging if tests fail. To read more about the Tests tab and test insights in CircleCI, visit the <<collect-test-data#,Collecting Test Data>> document.

Here is a full copy of the updated configuration:

[source,yaml]
----
version: 2.1

orbs:
    node: circleci/node@4.7

jobs:
    build-and-test:
        docker:
            - image: cimg/node:16.10
        parallelism: 5
        steps:
            - checkout
            - node/install-packages:
                pkg-manager: yarn
            - run: mkdir ~/junit
            - run:
                name: Test application
                command: |
                    TEST=$(circleci tests glob "src/__tests__/*.js" | circleci tests split --split-by=timings)
                    yarn test $TEST
            - run:
                command: cp junit.xml ~/junit/
                when: always
            - store_test_results:
                path: ~/junit

workflows:
    sample:
      jobs:
        - build-and-test
----

Once you have made these changes to `.circleci/config.yml`, go ahead and push the changes. This triggers the pipeline and runs the tests again, but this time the results are stored.

== ステップ 3: 結果を確認する

In the CircleCI web app, take a look at the steps in the recently triggered pipeline by clicking on the **Success** status and opening the `build-and-test` job.

. You may have noticed that this pipeline ran more quickly compared to earlier. The Node orb automatically caches node packages by default, so a cache exists from the earlier pipeline run. This helps speed up the install step.
. You should also now see five **parallel runs**, as a result of the number of execution environments set by the `parallelism` key. Each Docker environment (node) is labeled by its index number (so you have numbers 0 through 4). You can click on each node to see the individual steps that executed in each parallel run. The environment you are viewing will be highlighted in green.
+
image::{{site.baseurl}}/assets/img/docs/test-splitting-parallel-runs.png[Five parallel runs with run times displayed]
+
You might also notice that the parallel run times are not all equal, nor is the overall run time of the pipeline cut down to precisely 1/5. Each executor runs the same steps, but there is a difference in terms of which environment runs which tests. There may also be some variation in how long each executor takes to spin up.
+
Splitting tests by timing is the best way to ensure tests are split as evenly as possible and parallel runs finish around the same time. With that said, you may need to play around with the parallelism level to find the number that works best for you.
. In any of the parallel runs, open the **Test application** step. You will see which test suites and how many individual tests were executed in this particular run. You will also see this message in the output:
+
    Error reading historical timing data: file does not exist
Requested weighting by historical based timing, but they are not present. Falling back to weighting by name.
+
Since this is the first time you are storing test data from the pipeline, CircleCI does not currently have timing data to work with, so it defaults to splitting tests by name.
. Open the **Timing** tab in the job. This tab provides a visualization of how each parallel run did relative to each other.
+
image::{{site.baseurl}}/assets/img/docs/test-splitting-timing-tab.png[Parallel runs visualization in Timings tab]
+
The chart indicates which three steps within each run took the longest to complete. Hover over each section of the bar to see those respective steps.
+
You may also notice on the upper right corner within the Timing tab an indicator for idle time. In this pipeline, there was a total of 11 seconds between each finished run and the end of the longest run.

== ステップ 4: タイミングデータで分割する

In the previous step, you saw that test splitting defaulted to splitting tests based on name. Now that test data has been saved, CircleCI can now split your tests by timing the next time the pipeline runs.

. Commit a change in your project to trigger the pipeline again.
+
For example, you can try upgrading to a newer version of the Node orb, such as `circleci/node@5.0.2`. Or, you may choose to just trigger a pipeline again, by going to your project **Dashboard** in the web app and clicking the **Trigger Pipeline** Rerun button.
. Open the pipeline in the web app, and view the **Test application** step. This time, you should see `Autodetected filename timings.` in the output. This means that CircleCI is now splitting tests based on available timing data from preceding runs.
+
image::{{site.baseurl}}/assets/img/docs/test-splitting-by-timing.png[Testing step showing split by timing]
. Lastly, open the **Timing** tab. In this particular example, you might find that the time taken for the testing step to complete is not drastically different from earlier, when tests were split by name. However, you may notice that the idle time between runs has now been cut down to only five seconds, compared to 11 seconds from earlier.

== まとめ

このチュートリアルでは、並列実行コマンドと `circleci tests` コマンドを使ってテストをタイミングデータで分割するように設定しました。 この結果を保存すると、テストデータやインサイトにアクセスし更に深く分析することができます。

== 次のステップ

* このチュートリアルで使用されているデモの詳細については、ブログ記事 [テスト分割ガイド (英語)] をお読みください。
* CircleCI の <<insights-tests#,テストインサイト>> ついて